
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>DCS - 2.2</title>

    <!--- Math.js library, for matrix manipulation, and many other things--->
    <script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>
</head>

<body>

<h1>DCS - 2.2 Properties of conics</h1>
<canvas id="canvas1" height="600" width="600" class="bezier"  style="border:1px solid #d3d3d3;"></canvas>
<div style="padding-left: 20px; width:800px">
    <h2>Explanation</h2>
    <p> To explain a reflection property of a parabola I will consider the parabola
        This is a general case and I will use it to make the explanations easier.
    </p>
    <p>
        Let's take function f(x) = ax<sup>2</sup>.
        Imagine a parallel ray reflecting in the parabola. Let's name the intersection point as P=(x<sub>o</sub>, y<sub>o</sub>).
        <br>Let's construct a line tangent to the parabola in point P. It has a formula of:
        y: a<sub>t</sub>x + b<sub>t</sub>
        <br>a<sub>t</sub> is equal to the value of f'(x<sub>0</sub>)
        <br> f'(x<sub>0</sub>) = 2 * a * x<sub>0</sub>

        As we know from physics lesson The law of reflection states that angle of incidence equals the angle of reflection.
        Let's look at this general case drawing. <br>
        <img style="width: 300px" src="assignment2_2_pic.png">
        <br>Let's find a formula for the reflection line (the one going through G and B).
        <br>y<sub>f</sub> = a<sub>f</sub>x + b<sub>f</sub>
        <br>y<sub>f</sub> = tg(β)x  + b<sub>f</sub> .
        <br> Firstly notice that: γ + γ + 90° - β = 180°
        <br> That is: β = 2γ - 90°
        <br> Also: γ = α because γ + 90° == α + 90°
        <br> tg(β) = tg(2γ - 90°) = (some calculations) = - 1 / tg(2α)
        <br><img style="max-width: 150px" src="tg2alfa.png">
        <br> tg(β) = tg<sup>2</sup>(α) - 1 / (2 * tg(α))
        <br> tg(α) is easy to compute. It equals to f'(x<sub>0</sub>) = 2ax<sub>0</sub>
        <br>
        <br> tg(β) = (4a<sup>2</sup>x<sub>0</sub><sup>2</sup> - 1) / (4ax<sub>0</sub>)
        <br><br>
        For the computation of y<sub>f</sub> we still lack b<sub>f</sub>. <br>
        we know that the B point lays on the intersection of parabola and the y<sub>b</sub><br>

        (4a<sup>2</sup>x<sub>0</sub><sup>2</sup> - 1) / (4ax<sub>0</sub>) * x<sub>0</sub>  + b<sub>f</sub> = a x<sub>0</sub><sup>2</sup>
        <br>
        (some calculations)<br>
        b<sub>f</sub> =  - 1 / (4a)<br>

        y(0) = a<sub>f</sub> * 0 + b<sub>f</sub> = b<sub>f</sub> = -0.25a
        <br><br> It is clearly visible that no matter what value of x<sub>0</sub> we choose
        (in other words: no matter where the ray is gonna "hit" the parabola) the reflection line will <b>always</b>
        go through point (0, -0.25/a).
        This proves the focal property of parabola
    </p>
    <p>
        Although I have explained how it works only in a general case, one can imagine easily that
        we can obtain any parabola by translating this function by a vector (as we know we can write a formula for any
        parabola by translating a function f(x) = ax<sup>2</sup> within a vector (v<sub>x</sub>, v<sub>y</sub>).
        Thus, it means that the focal property stays the same, just the focus point will be moved by this vector as well.
    </p>
    <p>
        In this example the parabole equation is y = x<sup>2</sup>/200. <br>
        "a" coeffficient equals to 1/200, so the focus point is:<br>
        [0, -1/(4 * 1/200)] = [0, 50]
    </p>
</div>


<script type="text/javascript">

    /*
    * Part of this code is based on:
        * http://blogs.sitepoint.com/html5-canvas-draw-quadratic-curves/
        * http://blogs.sitepoint.com/html5-canvas-draw-bezier-curves/
    */

    var canvas1, context1, points, myTransformation, style, drag = null, draggedPoint;
    let numberOfRays = 10;
    let aCoefficientForParabola = 1/200;
    var colors = ['#FF6633', '#FFB399',  '#00B3E6',
        '#E6B333', '#3366E6', '#999966', '#99FF99', '#B34D4D',
        '#80B300', '#809900', '#E6B3B3', '#6680B3', '#66991A',
        '#FF99E6', '#FF1A66', '#E6331A', '#33FFCC',
        '#66994D', '#B366CC', '#4D8000', '#B33300', '#CC80CC',
        '#66664D', '#991AFF', '#E666FF', '#4DB3FF', '#1AB399',
        '#E666B3', '#33991A', '#CC9999', '#B3B31A',
        '#4D8066', '#809980', '#999933',
        '#FF3380', '#4D80CC', '#9900B3',
        '#E64D66', '#4DB380', '#FF4D4D', '#99E6E6', '#6666FF'];

    // TODO replace these points but those of the corresponding conic function (on-the-fly)
    points = [];

    function conicFunction (x){
        return aCoefficientForParabola * x * x ;
    }

    function computeConicPoints(){
        for (let i = -300; i < 300; i++) {
            points.push({x: i, y: conicFunction(i)})
        }

    }

    function init() {

        myTransformation = function(p){return p}; //Identity transform

        // default styles
        style = {
            curve:	{ width: 2, color: "#333" },
            line:	{ width: 2, color: "#C00" },
            point: { radius: 10, width: 2, color: "#900", fill: "rgba(200,200,200,0.5)", arc1: 0, arc2: 2 * Math.PI }
        };

        computeConicPoints();

        // line style defaults
        context1.lineCap = "round";
        context1.lineJoin = "round";

        // Translate origin to center of canvas
        context1.translate(canvas1.width/2, canvas1.height/2);
		
		// Flip y-axis, so it looks like in standard math axes
		context1.scale(1,-1) // Reversed y-axis

        drawCanvas();

    }


    /**
     Basic drawing methods
     **/


    // draw canvas
    function drawCanvas() {
        // Clear everything
        context1.clearRect(0, 0, canvas1.width, canvas1.height);  // Clear canvas

        // Background grids
        drawGrid(context1,canvas1.width, canvas1.height); // Draw background grid

        // Original points and vertices
        drawCurve(context1, style, points); // Draw curve
        // drawVertices(context1, style, points); // Draw vertices as circles

    }


    // Draw a background grid
    function drawGrid(myContext,bw,bh){
        var delta = 50; // grid cell size

        var half_width = bw/2;
        var half_height = bh/2;
        for (var x = -half_width; x <= half_width; x += delta) {
            myContext.moveTo(x, -half_height);
            myContext.lineTo(x, half_height);
        }
        for (var y = -half_height; y <= half_height; y += delta) {
            myContext.moveTo(-half_width, y);
            myContext.lineTo(half_width , y);
        }

        myContext.lineWidth = 1;
        myContext.strokeStyle = "lightgray";
        myContext.stroke();

        myContext.strokeStyle = "black";
        myContext.font = "12px Arial";
        myContext.fillText("(0,0)",2,12);

    }

    // Draws a polygonal curve connecting the points, after applying the given transformation
    function drawCurve(ctx, style, points, transformation) {
        // The transformation is optional. If none provided, use identity transform
        if (transformation===undefined) {
            transformation = function(p){return p}; //Identity transform
        }

        // Draw curve
        ctx.lineWidth = style.curve.width;
        ctx.strokeStyle = style.curve.color;
        ctx.beginPath();
        var firstPoint = transformation(points[0]);
        var currentPoint;
        ctx.moveTo(firstPoint.x, firstPoint.y);
        for (var i = 0; i < points.length; i++) {
            currentPoint =  transformation(points[i]);
            ctx.lineTo(currentPoint.x, currentPoint.y);
            ctx.moveTo(currentPoint.x, currentPoint.y);
        }
        ctx.stroke();
    }


    function drawSegment(ctx, style, color, pointFrom, pointTo){
        ctx.lineWidth = style.line.width;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(pointFrom.x, pointFrom.y);

        ctx.lineTo(pointTo.x, pointTo.y);
        ctx.moveTo(pointTo.x, pointTo.y);
        // }
        ctx.stroke();
    }
    /**
     * Start ("main method")
     */

    // Assign canvas and context variables
    canvas1 = document.getElementById("canvas1");
    context1 = canvas1.getContext("2d");

    init();
    drawVerticalLines();


    function drawVerticalLines(){
        let focusPoint = {x: 0, y:1/ (4 * aCoefficientForParabola)};
        for(let i=0; i < numberOfRays; i++){
            let randomXValue = Math.floor(Math.random() * 600) - 300;
            let conicValue = conicFunction(randomXValue);
            let color = colors[Math.floor(Math.random() * colors.length)];
            drawSegment(context1, style, color, {x: randomXValue, y: 300}, {x: randomXValue, y: conicValue})
            drawSegment(context1, style, color, {x: randomXValue, y: conicValue}, focusPoint)
        }

    }

    function doReset () {
        myTransformation = function(p){return p}; //Identity transform
        drawCanvas();
    }


</script>
</body>
</html>